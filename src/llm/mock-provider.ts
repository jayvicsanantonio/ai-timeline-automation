import type { LLMProvider } from './provider';
import type {
  LLMBudgetConfig,
  LLMCompletionRequest,
  LLMCompletionResult,
  LLMEmbeddingRequest,
  LLMEmbeddingResult
} from './types';

export class MockLLMProvider implements LLMProvider {
  readonly id = 'mock_llm';
  readonly model = 'mock-1';

  supportsEmbeddings(): boolean {
    return true;
  }

  updateBudget(_budget: LLMBudgetConfig): void {
    // Budget limits are not enforced in the mock provider.
  }

  async complete(request: LLMCompletionRequest): Promise<LLMCompletionResult> {
    if (process.env.LLM_DEBUG === 'true') {
      console.log('[MockLLMProvider] Generating completion for request');
    }
    const userPrompt = request.messages
      .filter((message) => message.role === 'user')
      .map((message) => message.content)
      .join('\n');

    const synthesized = this.buildSyntheticAnalysis(userPrompt);

    return {
      providerId: this.id,
      text: JSON.stringify(synthesized),
      finishReason: 'stop',
      usage: {
        prompt: Math.ceil(userPrompt.length / 4),
        completion: Math.ceil(JSON.stringify(synthesized).length / 4),
        total: Math.ceil(userPrompt.length / 4) + Math.ceil(JSON.stringify(synthesized).length / 4)
      }
    };
  }

  async embed(request: LLMEmbeddingRequest): Promise<LLMEmbeddingResult> {
    const inputs = Array.isArray(request.input) ? request.input : [request.input];

    const vectors = inputs.map((input) => this.toUnitVector(input));

    return {
      providerId: this.id,
      vectors,
      usage: {
        prompt: 0,
        completion: 0,
        total: 0
      }
    };
  }

  private buildSyntheticAnalysis(prompt: string) {
    const sanitizedPrompt = prompt.replace(/\s+/g, ' ').trim();
    const title = sanitizedPrompt.slice(0, 96) || 'AI development update';

    const baseScore = Math.min(9.3, Math.max(7.2, sanitizedPrompt.length / 200 + 7));

    const bucketedScore = (offset: number) =>
      Number(Math.min(10, Math.max(0, baseScore + offset)).toFixed(1));

    const insights = this.extractSentences(sanitizedPrompt, 3);
    const topics = this.extractKeywords(sanitizedPrompt, 4);

    return {
      title,
      description:
        sanitizedPrompt.slice(0, 480) ||
        'Automated summary generated by mock provider for development runs.',
      category: this.deriveCategory(sanitizedPrompt),
      significance: {
        technologicalBreakthrough: bucketedScore(0.3),
        industryImpact: bucketedScore(-0.2),
        adoptionScale: bucketedScore(-0.1),
        novelty: bucketedScore(0.4)
      },
      keyInsights:
        insights.length > 0
          ? insights
          : ['Automated mock analysis summary.', 'Use real providers in production environments.'],
      relatedTopics: topics.length > 0 ? topics : ['ai', 'automation', 'mock-provider']
    };
  }

  private extractSentences(text: string, limit: number): string[] {
    const sentences = text
      .split(/[.!?]/)
      .map((sentence) => sentence.trim())
      .filter(Boolean)
      .map((sentence) => sentence.slice(0, 160));

    return sentences.slice(0, limit);
  }

  private extractKeywords(text: string, limit: number): string[] {
    const words = text
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter((word) => word.length > 3 && word.length < 18);

    const frequency = new Map<string, number>();
    for (const word of words) {
      frequency.set(word, (frequency.get(word) || 0) + 1);
    }

    return Array.from(frequency.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([word]) => word)
      .filter(
        (word) =>
          !['https', 'http', 'httpswww', 'introduction', 'analysis', 'development'].includes(word)
      )
      .filter((word, index, array) => array.indexOf(word) === index)
      .slice(0, limit);
  }

  private toUnitVector(text: string): number[] {
    const dims = 12;
    const vector = new Array(dims).fill(0);

    for (let i = 0; i < text.length; i++) {
      vector[i % dims] += text.charCodeAt(i);
    }

    const norm = Math.sqrt(vector.reduce((sum, value) => sum + value * value, 0)) || 1;
    return vector.map((value) => Number((value / norm).toFixed(6)));
  }

  private deriveCategory(text: string): 'research' | 'product' | 'regulation' | 'industry' {
    const sample = text.toLowerCase();

    if (
      sample.includes('regulation') ||
      sample.includes('compliance') ||
      sample.includes('policy')
    ) {
      return 'regulation';
    }

    if (sample.includes('release') || sample.includes('product') || sample.includes('launch')) {
      return 'product';
    }

    if (
      sample.includes('deployment') ||
      sample.includes('partnership') ||
      sample.includes('adoption')
    ) {
      return 'industry';
    }

    return 'research';
  }
}
